<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Staging Tools - File Service</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; color: #222; }
    h1 { margin: 0 0 12px; }
    fieldset { border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-bottom: 16px; }
    legend { font-weight: 600; }
    label { display: inline-block; margin-right: 12px; }
    input[type="text"] { width: 360px; padding: 6px 8px; border: 1px solid #ccc; border-radius: 6px; }
    input[type="file"] { padding: 6px 0; }
    button { padding: 8px 12px; border: 1px solid #0078d4; background: #0078d4; color: #fff; border-radius: 6px; cursor: pointer; }
    button.secondary { border-color: #555; background: #fff; color: #222; }
    button + button { margin-left: 8px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .muted { color: #666; }
    .progress { height: 10px; background: #eee; border-radius: 6px; overflow: hidden; margin-top: 8px; }
    .bar { height: 100%; background: #28a745; width: 0%; transition: width 0.1s linear; }
    .stats { margin-top: 6px; font-size: 13px; }
    table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; }
    th { background: #f7f7f7; }
    .right { text-align: right; }
    .danger { background: #c62828; border-color: #c62828; }
    .success { color: #1b5e20; }
    .error { color: #b00020; }
    .hidden { display: none; }
    .small { font-size: 12px; }
  </style>
</head>
<body>
  <h1>Staging Tools</h1>
  <p class="muted small">Calls the staging environment APIs directly. Provide PowerSchool user & role headers to authenticate.</p>

  <fieldset>
    <legend>Environment & Auth</legend>
    <div class="row">
      <label>
        Base URL
        <input id="baseUrl" type="text" value="https://filesvc-stg-app.kaiweneducation.com" />
      </label>
      <label>
        X-PowerSchool-User
        <input id="psUser" type="text" value="admin1"/>
      </label>
      <label>
        X-PowerSchool-Role
        <input id="psRole" type="text" value="admin" />
      </label>
      <label>
        <input id="includeAll" type="checkbox" checked /> Include all users (admin only)
      </label>
    </div>
    <div class="small muted">Ensure your app’s CORS allows this page’s origin. If loading from file://, some browsers restrict requests; prefer serving via a local HTTP server.</div>
  </fieldset>

  <fieldset>
    <legend>Upload Files</legend>
    <div class="row">
      <input id="singleFile" type="file" />
      <button id="btnUploadSingle">Upload One</button>
    </div>
    <div class="row" style="margin-top:8px;">
      <input id="multiFiles" type="file" multiple />
      <button id="btnUploadMulti">Upload Multiple</button>
      <button id="btnCancelUploads" class="secondary">Cancel</button>
    </div>
    <div class="progress"><div id="progressBar" class="bar"></div></div>
    <div id="progressStats" class="stats muted">Idle</div>
    <div id="uploadStatus" class="small"></div>
  </fieldset>

  <fieldset>
    <legend>Files</legend>
    <div class="row">
      <button id="btnRefresh">Refresh List</button>
      <button id="btnDeleteSelected" class="danger">Delete Selected</button>
      <button id="btnDownloadSelected" class="secondary" style="border-color: #0078d4; color: #0078d4;">Download Selected (Zip)</button>
    </div>
    <table id="filesTable">
      <thead>
        <tr>
          <th><input type="checkbox" id="checkAll" /></th>
          <th>File Name</th>
          <th>Content Type</th>
          <th class="right">Size</th>
          <th>Owner</th>
          <th>Uploaded At</th>
          <th>Actions</th>
          <th>Id</th>
        </tr>
      </thead>
      <tbody id="filesBody"></tbody>
    </table>
    <div id="listStatus" class="small"></div>
  </fieldset>

  <script>
    const el = id => document.getElementById(id);

    const state = {
      abortController: null,
      totalBytes: 0,
      uploadedBytes: 0,
      startTime: 0,
      lastUpdateTime: 0,
      lastUploadedBytes: 0,
    };

    function headers() {
      const h = new Headers();
      const user = el('psUser').value.trim();
      const role = el('psRole').value.trim();
      if (user) h.set('X-PowerSchool-User', user);
      if (role) h.set('X-PowerSchool-Role', role);
      return h;
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024, sizes = ['B','KB','MB','GB','TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return `${(bytes / Math.pow(k, i)).toFixed(2)} ${sizes[i]}`;
    }

    function setProgress(percent, speedBps) {
      const pct = Math.max(0, Math.min(100, percent));
      el('progressBar').style.width = pct + '%';
      const speed = speedBps ? `${formatBytes(speedBps)}/s` : '—';
      const stats = `Progress: ${pct.toFixed(1)}% • Speed: ${speed} • ${formatBytes(state.uploadedBytes)} / ${formatBytes(state.totalBytes)}`;
      el('progressStats').textContent = stats;
    }

    function resetProgress() {
      state.totalBytes = 0;
      state.uploadedBytes = 0;
      state.startTime = 0;
      state.lastUpdateTime = 0;
      state.lastUploadedBytes = 0;
      setProgress(0, 0);
      el('uploadStatus').textContent = '';
    }

    function xhrUpload(file, baseUrl) {
      return new Promise(async (resolve, reject) => {
        try {
          // Step 1: Begin Upload (Get SAS)
          const beginPayload = {
            fileName: file.name,
            sizeBytes: file.size,
            contentType: file.type || 'application/octet-stream'
          };
          
          el('uploadStatus').innerHTML = 'Requesting upload slot...';
          const beginRes = await fetch(`${baseUrl}/api/files/begin-upload`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              ...Object.fromEntries(headers())
            },
            body: JSON.stringify(beginPayload)
          });

          if (!beginRes.ok) {
              const errText = await beginRes.text();
              throw new Error(`Begin-upload failed: ${beginRes.status} - ${errText}`);
          }
          const beginJson = await beginRes.json();
          const fileId = beginJson.fileId || beginJson.FileId;
          const uploadUrl = beginJson.uploadUrl || beginJson.UploadUrl;

          if (!fileId || !uploadUrl) throw new Error('Invalid server response (missing fileId or uploadUrl)');

          // Step 2: Upload to Blob (Direct PUT)
          el('uploadStatus').innerHTML = 'Uploading to blob storage...';
          
          const xhr = new XMLHttpRequest();
          xhr.open('PUT', uploadUrl);
          xhr.setRequestHeader('x-ms-blob-type', 'BlockBlob'); // Vital for Azure Block Blobs
          // No auth headers here - SAS token is in the URL

          xhr.upload.onprogress = (e) => {
            if (e.lengthComputable) {
              const now = performance.now();
              // Calculate delta since last progress event isn't easy with multiple files,
              // so we just track total for "this" file relative to global state?
              // Simplified: We assume single stream tracking for the bar here.
              // For multi-file, this logic is a bit simple but suffices for a tool.
              const currentFileUploaded = e.loaded; // Bytes uploaded for THIS file
              // We need to feed this back to the global state. 
              // BUT: The global state design above (state.uploadedBytes) accumulates.
              // Let's just update the UI with "current file" logic or fix the tracker.
              // Fix: We'll just update based on delta from THIS XHR instance.
              
              const delta = e.loaded - (xhr.lastLoaded || 0);
              xhr.lastLoaded = e.loaded;
              
              state.uploadedBytes += delta;
              const elapsedMs = now - state.startTime;
              const speed = elapsedMs > 0 ? (state.uploadedBytes / (elapsedMs / 1000)) : 0;
              const percent = state.totalBytes > 0 ? (state.uploadedBytes / state.totalBytes) * 100 : 0;
              setProgress(percent, speed);
            }
          };

          xhr.onreadystatechange = async () => {
            if (xhr.readyState === 4) {
              if (xhr.status >= 200 && xhr.status < 300) {
                 // Step 3: Complete Upload
                 try {
                     el('uploadStatus').innerHTML = 'Finalizing upload...';
                     const completeRes = await fetch(`${baseUrl}/api/files/complete-upload/${fileId}`, {
                         method: 'POST',
                         headers: Object.fromEntries(headers())
                     });
                     if (!completeRes.ok) {
                         const errText = await completeRes.text();
                         throw new Error(`Complete-upload failed: ${completeRes.status} - ${errText}`);
                     }
                     resolve('OK');
                 } catch (err) {
                     reject(err);
                 }
              } else {
                reject(new Error(`Blob upload failed: ${xhr.status} ${xhr.statusText}`));
              }
            }
          };

          xhr.onerror = () => reject(new Error('Network error during blob upload'));
          xhr.onabort = () => reject(new Error('Upload aborted'));
          xhr.send(file);
          
        } catch (err) {
          reject(err);
        }
      });
    }

    async function uploadSingle() {
      resetProgress();
      const baseUrl = el('baseUrl').value.trim();
      const userHdr = el('psUser').value.trim();
      if (!userHdr) { el('uploadStatus').innerHTML = '<span class="error">Please enter X-PowerSchool-User.</span>'; return; }
      const file = el('singleFile').files[0];
      if (!file) { el('uploadStatus').textContent = 'Please choose a file.'; return; }

      state.totalBytes = file.size;
      state.startTime = performance.now();
      state.lastUploadedBytes = 0;
      try {
        await xhrUpload(file, baseUrl);
        setProgress(100, 0);
        el('uploadStatus').innerHTML = '<span class="success">Upload complete.</span>';
        await refreshList();
      } catch (err) {
        el('uploadStatus').innerHTML = `<span class="error">${err.message}</span>`;
      }
    }

    async function uploadMultiple() {
      resetProgress();
      const baseUrl = el('baseUrl').value.trim();
      const userHdr = el('psUser').value.trim();
      if (!userHdr) { el('uploadStatus').innerHTML = '<span class="error">Please enter X-PowerSchool-User.</span>'; return; }
      const files = Array.from(el('multiFiles').files || []);
      if (files.length === 0) { el('uploadStatus').textContent = 'Please choose files.'; return; }

      state.totalBytes = files.reduce((sum, f) => sum + f.size, 0);
      state.startTime = performance.now();
      try {
        for (const file of files) {
          state.lastUploadedBytes = 0; // per-file progress baseline
          await xhrUpload(file, baseUrl);
        }
        setProgress(100, 0);
        el('uploadStatus').innerHTML = `<span class="success">Uploaded ${files.length} files.</span>`;
        await refreshList();
      } catch (err) {
        el('uploadStatus').innerHTML = `<span class="error">${err.message}</span>`;
      }
    }

    async function refreshList() {
      const baseUrl = el('baseUrl').value.trim();
      const includeAll = el('includeAll').checked;
      const url = `${baseUrl}/api/files${includeAll ? '?all=true' : ''}`;
      el('listStatus').textContent = 'Loading...';
      try {
        const res = await fetch(url, { headers: headers(), mode: 'cors' });
        if (!res.ok) throw new Error(`List failed: ${res.status}`);
        const data = await res.json();
        renderList(Array.isArray(data) ? data : []);
        el('listStatus').textContent = `Loaded ${Array.isArray(data) ? data.length : 0} items.`;
      } catch (err) {
        el('listStatus').innerHTML = `<span class="error">${err.message}</span>`;
      }
    }

    function renderList(items) {
      const tbody = el('filesBody');
      tbody.innerHTML = '';
      for (const item of items) {
        const tr = document.createElement('tr');
        const size = item.SizeBytes ?? item.sizeBytes ?? item.Size ?? 0;
        const uploadedAt = item.UploadedAt ?? item.uploadedAt ?? item.CreatedAt ?? '';
        const owner = item.OwnerUserId ?? item.ownerUserId ?? item.CreatedBy ?? '';
        const id = item.Id ?? item.id ?? '';
        const name = item.FileName ?? item.fileName ?? '';
        const ct = item.ContentType ?? item.contentType ?? '';

        tr.innerHTML = `
          <td><input type="checkbox" class="rowCheck" data-id="${id}" /></td>
          <td>${name}</td>
          <td>${ct}</td>
          <td class="right">${formatBytes(Number(size) || 0)}</td>
          <td>${owner}</td>
          <td>${uploadedAt ? new Date(uploadedAt).toLocaleString() : ''}</td>
          <td>
            <button class="small-btn download-btn" data-id="${id}">Download</button>
          </td>
          <td class="small">${id}</td>
        `;
        tbody.appendChild(tr);
      }
      
      // Wire up row buttons
      document.querySelectorAll('.download-btn').forEach(btn => {
          btn.addEventListener('click', (e) => downloadOne(e.target.getAttribute('data-id')));
      });
    }

    async function downloadOne(id) {
        const baseUrl = el('baseUrl').value.trim();
        try {
            // Get SAS URL
            const res = await fetch(`${baseUrl}/api/files/${id}`, { headers: headers(), mode: 'cors' });
            if (!res.ok) throw new Error(`Get failed: ${res.status}`);
            const data = await res.json();
            const url = data.downloadUrl || data.DownloadUrl; // Case sensitivity check
            if (url) {
                window.open(url, '_blank');
            } else {
                alert('No download URL returned');
            }
        } catch (err) {
            alert('Download error: ' + err.message);
        }
    }

    async function downloadSelectedZip() {
      const baseUrl = el('baseUrl').value.trim();
      const checks = Array.from(document.querySelectorAll('.rowCheck:checked'));
      if (checks.length === 0) { el('listStatus').textContent = 'No files selected.'; return; }
      
      const ids = checks.map(c => c.getAttribute('data-id'));
      el('listStatus').textContent = `Zipping ${ids.length} files...`;
      
      try {
          // 1. Start Job
          el('listStatus').textContent = `Requesting zip for ${ids.length} files...`;
          const res = await fetch(`${baseUrl}/api/files/download-zip`, {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
                  ...Object.fromEntries(headers())
              },
              body: JSON.stringify(ids)
          });
          
          if (res.status !== 202) {
              // Fallback for old behaviour if any (or error)
               if (!res.ok) throw new Error(`Zip request failed: ${res.status}`);
               // Direct download buffer response?
               const blob = await res.blob();
               if (blob.size === 0) throw new Error("Received 0 bytes");
               downloadBlob(blob);
               return;
          }

          const jobJson = await res.json();
          const jobId = jobJson.jobId || jobJson.JobId;
          el('listStatus').textContent = `Zip job started (${jobId}). Processing...`;

          // 2. Poll Status
          await pollZipJob(baseUrl, jobId);
          
      } catch (err) {
          el('listStatus').innerHTML = `<span class="error">${err.message}</span>`;
      }
    }

    async function pollZipJob(baseUrl, jobId) {
        let attempts = 0;
        const maxAttempts = 60; // 2 minutes approx
        
        const interval = setInterval(async () => {
            attempts++;
            try {
                const res = await fetch(`${baseUrl}/api/files/download-zip/${jobId}`, { headers: headers() });
                if (!res.ok) throw new Error("Poll failed");
                const job = await res.json();
                
                if (job.status === 'Completed' || job.Status === 'Completed') {
                    clearInterval(interval);
                    const url = job.downloadUrl || job.DownloadUrl;
                    if (!url) {
                        el('listStatus').innerHTML = `<span class="error">Zip ready but no download URL returned.</span>`;
                        return;
                    }

                    // Provide a clickable link and navigate directly (avoids popup blockers)
                    const linkHtml = `<a href="${url}" target="_blank">Download zip</a>`;
                    el('listStatus').innerHTML = `<span class="success">Zip ready! ${linkHtml}</span>`;
                    window.location.href = url;

                    // Delay cleanup to allow download to start; still frees storage automatically
                    setTimeout(async () => {
                        try {
                            await fetch(`${baseUrl}/api/files/download-zip/${jobId}`, { 
                                method: 'DELETE', 
                                headers: headers() 
                            });
                            console.log('Zip file cleaned up from storage');
                        } catch (err) {
                            console.error('Cleanup failed:', err);
                        }
                    }, 30000);
                } else if (job.status === 'Failed' || job.Status === 'Failed') {
                    clearInterval(interval);
                    el('listStatus').innerHTML = `<span class="error">Zip generation failed: ${job.error || job.Error}</span>`;
                } else {
                    el('listStatus').textContent = `Processing zip... (${attempts}s)`;
                }

                if (attempts >= maxAttempts) {
                    clearInterval(interval);
                    el('listStatus').textContent = "Zip generation timed out (check back later?)";
                }
            } catch (err) {
                console.error(err);
                // Keep trying or stop?
            }
        }, 2000);
    }

    function downloadBlob(blob) {
         const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.style.display = 'none';
          a.href = url;
          a.download = `files_export_${new Date().getTime()}.zip`;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          el('listStatus').textContent = 'Zip download started.';
    }

    async function deleteSelected() {
      const baseUrl = el('baseUrl').value.trim();
      const checks = Array.from(document.querySelectorAll('.rowCheck:checked'));
      if (checks.length === 0) { el('listStatus').textContent = 'No files selected.'; return; }
      el('listStatus').textContent = `Deleting ${checks.length} files...`;
      let ok = 0, fail = 0;
      for (const c of checks) {
        const id = c.getAttribute('data-id');
        try {
          const res = await fetch(`${baseUrl}/api/files/${id}`, { method: 'DELETE', headers: headers(), mode: 'cors' });
          if (res.ok) ok++; else fail++;
        } catch { fail++; }
      }
      el('listStatus').textContent = `Deleted ${ok}, failed ${fail}.`;
      await refreshList();
    }

    // Check all toggle
    el('checkAll').addEventListener('change', (e) => {
      const checked = e.target.checked;
      document.querySelectorAll('.rowCheck').forEach(cb => cb.checked = checked);
    });

    // Wire buttons
    el('btnUploadSingle').addEventListener('click', uploadSingle);
    el('btnUploadMulti').addEventListener('click', uploadMultiple);
    el('btnRefresh').addEventListener('click', refreshList);
    el('btnDeleteSelected').addEventListener('click', deleteSelected);
    el('btnDownloadSelected').addEventListener('click', downloadSelectedZip);

    // Initial list
    // Optionally auto-load list on page ready
    // refreshList();
  </script>
</body>
</html>
