<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Service Tools - PowerSchool</title>
    <!-- PowerSchool user context (server-rendered by PowerSchool) -->
    <meta name="ps-userid" content="~[x:userid]">
    <meta name="ps-usersroles" content="~[x:usersroles]">
    ~[wc:commonscripts] 
    <link href="/images/css/screen.css" rel="stylesheet" media="screen">
    <link href="/images/css/print.css" rel="stylesheet" media="print">
    <link href="FileServiceTools.css" rel="stylesheet" media="screen">
</head>
<body>
    ~[wc:admin_header_css] 
    <a href=" " target="_top">Start Page</a > &gt; File Service Tools
    ~[wc:admin_navigation_css]
    <div id="fs-root">
    <h1>File Service Tools</h1>
    <p class="fs-muted fs-small">Manage files via the File Service API. Your PowerSchool account is used for authentication.</p>
    
    <div class="fs-user-context">
        <strong>Authenticated as (UserId):</strong> <span id="displayUserId">~[x:userid]</span> <strong>| Role:</strong> <span id="displayRole">admin</span>
    </div>

    <fieldset>
        <legend>Upload Files</legend>
        <div class="fs-row">
            <input id="singleFile" type="file" />
            <button id="btnUploadSingle">Upload One</button>
        </div>
        <div class="fs-row fs-upload-row">
            <input id="multiFiles" type="file" multiple />
            <button id="btnUploadMulti">Upload Multiple</button>
            <button id="btnCancelUploads" class="fs-secondary">Cancel</button>
        </div>
        <div class="fs-progress"><div id="progressBar" class="fs-bar"></div></div>
        <div id="progressStats" class="fs-stats fs-muted">Idle</div>
        <div id="uploadStatus" class="fs-small"></div>
    </fieldset>

    <fieldset>
        <legend>Files</legend>
        <div class="fs-row">
            <button id="btnRefresh">Refresh List</button>
            <button id="btnDeleteSelected" class="fs-danger">Delete Selected</button>
            <button id="btnDownloadSelected" class="fs-secondary fs-outline-primary">Download Selected (Zip)</button>
        </div>
        <div class="fs-table-wrap">
            <table id="filesTable">
                <thead>
                    <tr>
                        <th><input type="checkbox" id="checkAll" /></th>
                        <th>File Name</th>
                        <th>Content Type</th>
                        <th class="fs-right">Size</th>
                        <th>Owner</th>
                        <th>Uploaded At</th>
                        <th>Actions</th>
                        <th>Id</th>
                    </tr>
                </thead>
                <tbody id="filesBody"></tbody>
            </table>
        </div>
        <div id="listStatus" class="fs-small"></div>
        <div id="pager"></div>
    </fieldset>

    <!-- Preview Modal -->
        <div id="previewOverlay" class="fs-preview-overlay fs-hidden">
        <div class="fs-preview-container">
            <div class="fs-preview-header">
                <strong id="previewTitle">Preview</strong>
                <div>
                    <button id="btnOpenInTab" class="fs-secondary fs-mr-8">Open in New Tab</button>
                    <button id="btnClosePreview" class="fs-secondary">Close</button>
                </div>
            </div>
            <div id="previewBody" class="fs-preview-body">
                <div class="fs-muted">Loading preview...</div>
            </div>
            <div id="previewFooter" class="fs-preview-footer fs-small fs-muted">If the preview fails, try Open in New Tab or Download.</div>
        </div>
    </div>

    <script>
        // File Service Tools - Plain HTML version
        // Works with PowerSchool authentication via headers
        
        const apiBaseUrl = 'https://filesvc-stg-app.kaiweneducation.com';
        
        const el = id => document.getElementById(id);

        const state = {
            abortController: null,
            totalBytes: 0,
            uploadedBytes: 0,
            startTime: 0,
            lastUpdateTime: 0,
            lastUploadedBytes: 0,
            listItems: [],
            selectedIds: new Set(),
            pageSize: 10,
            currentPage: 1,
        };

        function headers() {
            const h = new Headers();
            const qs = new URLSearchParams(window.location.search);
            // PowerSchool replaces these server-side before serving the page
            const username = '~[x:username]' || qs.get('user') || '';
            const userIdMeta = document.querySelector('meta[name="ps-userid"]');
            const userId = (userIdMeta && userIdMeta.content) ? userIdMeta.content : (qs.get('userid') || qs.get('userId') || '');
            const effectiveUserId = userId || username || 'unknown';

            // Always include stable ASCII-safe identifiers
            h.set('X-PowerSchool-UserId', String(effectiveUserId));
            h.set('X-PowerSchool-User', String(effectiveUserId));
            h.set('X-PowerSchool-Role', 'admin');

            // Helper to test Latin-1 safety
            const isLatin1 = (s) => {
                for (let i = 0; i < s.length; i++) { if (s.charCodeAt(i) > 255) return false; }
                return true;
            };

            // Optional: send display username for logging only
            try {
                if (username) h.set('X-PowerSchool-UserName', username);
            } catch (err) {
                console.warn('[FileServiceTools] Header set failed for username (logging only)', err);
            }

            // Provide full-fidelity username for servers that can decode it
            if (username && !isLatin1(username)) {
                const b64 = btoa(unescape(encodeURIComponent(username)));
                h.set('X-PowerSchool-UserName-B64', b64);
            }

            return h;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024, sizes = ['B','KB','MB','GB','TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
        }

        function setProgress(percent, speedBps) {
            const pct = Math.max(0, Math.min(100, percent));
            el('progressBar').style.width = pct + '%';
            const speed = speedBps ? formatBytes(speedBps) + '/s' : '-';
            const stats = 'Progress: ' + pct.toFixed(1) + '% - Speed: ' + speed + ' - ' + formatBytes(state.uploadedBytes) + ' / ' + formatBytes(state.totalBytes);
            el('progressStats').textContent = stats;
        }

        function resetProgress() {
            state.totalBytes = 0;
            state.uploadedBytes = 0;
            state.startTime = 0;
            state.lastUpdateTime = 0;
            state.lastUploadedBytes = 0;
            setProgress(0, 0);
            el('uploadStatus').textContent = '';
        }

        function xhrUpload(file) {
            return new Promise(async (resolve, reject) => {
                try {
                    const beginPayload = {
                        fileName: file.name,
                        sizeBytes: file.size,
                        contentType: file.type || 'application/octet-stream'
                    };
                    
                    el('uploadStatus').innerHTML = 'Requesting upload slot...';
                    const beginRes = await fetch(apiBaseUrl + '/api/files/begin-upload', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...Object.fromEntries(headers())
                        },
                        body: JSON.stringify(beginPayload)
                    });

                    if (!beginRes.ok) {
                        const errText = await beginRes.text();
                        throw new Error('Begin-upload failed: ' + beginRes.status + ' - ' + errText);
                    }
                    const beginJson = await beginRes.json();
                    const fileId = beginJson.fileId || beginJson.FileId;
                    const uploadUrl = beginJson.uploadUrl || beginJson.UploadUrl;

                    if (!fileId || !uploadUrl) throw new Error('Invalid server response');

                    el('uploadStatus').innerHTML = 'Uploading to blob storage...';
                    
                    const xhr = new XMLHttpRequest();
                    xhr.open('PUT', uploadUrl);
                    xhr.setRequestHeader('x-ms-blob-type', 'BlockBlob');
                    xhr.setRequestHeader('x-ms-blob-content-type', file.type || 'application/octet-stream');

                    xhr.upload.onprogress = (e) => {
                        if (e.lengthComputable) {
                            const now = performance.now();
                            const delta = e.loaded - (xhr.lastLoaded || 0);
                            xhr.lastLoaded = e.loaded;
                            state.uploadedBytes += delta;
                            const elapsedMs = now - state.startTime;
                            const speed = elapsedMs > 0 ? (state.uploadedBytes / (elapsedMs / 1000)) : 0;
                            const percent = state.totalBytes > 0 ? (state.uploadedBytes / state.totalBytes) * 100 : 0;
                            setProgress(percent, speed);
                        }
                    };

                    xhr.onreadystatechange = async () => {
                        if (xhr.readyState === 4) {
                            if (xhr.status >= 200 && xhr.status < 300) {
                                try {
                                    el('uploadStatus').innerHTML = 'Finalizing upload...';
                                    const completeRes = await fetch(apiBaseUrl + '/api/files/complete-upload/' + fileId, {
                                        method: 'POST',
                                        headers: Object.fromEntries(headers())
                                    });
                                    if (!completeRes.ok) {
                                        const errText = await completeRes.text();
                                        throw new Error('Complete-upload failed: ' + completeRes.status);
                                    }
                                    resolve('OK');
                                } catch (err) {
                                    reject(err);
                                }
                            } else {
                                reject(new Error('Blob upload failed: ' + xhr.status));
                            }
                        }
                    };

                    xhr.onerror = () => reject(new Error('Network error during blob upload'));
                    xhr.onabort = () => reject(new Error('Upload aborted'));
                    xhr.send(file);
                } catch (err) {
                    reject(err);
                }
            });
        }

        async function uploadSingle() {
            resetProgress();
            const file = el('singleFile').files[0];
            if (!file) { el('uploadStatus').textContent = 'Please choose a file.'; return; }
            state.totalBytes = file.size;
            state.startTime = performance.now();
            try {
                await xhrUpload(file);
                setProgress(100, 0);
                el('uploadStatus').innerHTML = '<span class="fs-success">Upload complete.</span>';
                await refreshList();
            } catch (err) {
                el('uploadStatus').innerHTML = '<span class="fs-error">' + err.message + '</span>';
            }
        }

        async function uploadMultiple() {
            resetProgress();
            const files = Array.from(el('multiFiles').files || []);
            if (files.length === 0) { el('uploadStatus').textContent = 'Please choose files.'; return; }
            state.totalBytes = files.reduce((sum, f) => sum + f.size, 0);
            state.startTime = performance.now();
            try {
                for (const file of files) {
                    await xhrUpload(file);
                }
                setProgress(100, 0);
                el('uploadStatus').innerHTML = '<span class="fs-success">Uploaded ' + files.length + ' files.</span>';
                await refreshList();
            } catch (err) {
                el('uploadStatus').innerHTML = '<span class="fs-error">' + err.message + '</span>';
            }
        }

        async function refreshList() {
            const url = apiBaseUrl + '/api/files';
            el('listStatus').textContent = 'Loading...';
            try {
                const res = await fetch(url, { headers: headers(), mode: 'cors' });
                if (!res.ok) throw new Error('List failed: ' + res.status);
                const data = await res.json();
                setList(Array.isArray(data) ? data : []);
                el('listStatus').textContent = '';
            } catch (err) {
                el('listStatus').innerHTML = '<span class="fs-error">' + err.message + '</span>';
            }
        }

        function setList(items) {
            state.listItems = items || [];
            state.selectedIds = new Set();
            state.currentPage = 1;
            renderTable();
        }

        function renderTable() {
            const total = state.listItems.length;
            const pages = Math.max(1, Math.ceil(total / state.pageSize));
            if (state.currentPage > pages) state.currentPage = pages;
            const start = (state.currentPage - 1) * state.pageSize;
            const pageItems = state.listItems.slice(start, start + state.pageSize);

            const tbody = el('filesBody');
            tbody.innerHTML = '';
            for (const item of pageItems) {
                const tr = document.createElement('tr');
                const size = item.SizeBytes || item.sizeBytes || 0;
                const uploadedAt = item.UploadedAt || item.uploadedAt || '';
                const owner = item.OwnerUserId || item.ownerUserId || '';
                const id = item.Id || item.id || '';
                const name = item.FileName || item.fileName || '';
                const ct = item.ContentType || item.contentType || '';

                const checkedAttr = state.selectedIds.has(String(id)) ? 'checked' : '';
                tr.innerHTML = '<td><input type="checkbox" class="rowCheck" data-id="' + id + '" ' + checkedAttr + ' /></td>' +
                    '<td>' + name + '</td>' +
                    '<td>' + ct + '</td>' +
                    '<td class="fs-right">' + formatBytes(Number(size) || 0) + '</td>' +
                    '<td>' + owner + '</td>' +
                    '<td>' + (uploadedAt ? new Date(uploadedAt).toLocaleString() : '') + '</td>' +
                    '<td><div class="fs-actions">' +
                    '<button class="fs-small-btn preview-btn" data-id="' + id + '">Preview</button>' +
                    '<button class="fs-small-btn download-btn" data-id="' + id + '">Download</button>' +
                    '</div></td>' +
                    '<td class="fs-small">' + id + '</td>';
                tbody.appendChild(tr);
            }

            document.querySelectorAll('.download-btn').forEach(btn => {
                btn.addEventListener('click', (e) => downloadOne(e.target.getAttribute('data-id')));
            });

            document.querySelectorAll('.preview-btn').forEach(btn => {
                btn.addEventListener('click', (e) => previewFile(e.target.getAttribute('data-id')));
            });

            document.querySelectorAll('.rowCheck').forEach(cb => {
                cb.addEventListener('change', (e) => {
                    const id = e.target.getAttribute('data-id');
                    if (e.target.checked) state.selectedIds.add(String(id));
                    else state.selectedIds.delete(String(id));
                });
            });

            el('checkAll').addEventListener('change', (e) => {
                document.querySelectorAll('.rowCheck').forEach(cb => {
                    cb.checked = e.target.checked;
                    const id = cb.getAttribute('data-id');
                    if (e.target.checked) state.selectedIds.add(String(id));
                    else state.selectedIds.delete(String(id));
                });
            });

            renderPager();
        }

        function renderPager() {
            const total = state.listItems.length;
            const pages = Math.max(1, Math.ceil(total / state.pageSize));
            const pagerDiv = el('pager');
            pagerDiv.innerHTML = '';

            if (pages <= 1) return;

            const prev = document.createElement('button');
            prev.className = 'fs-secondary';
            prev.textContent = 'Previous';
            prev.disabled = state.currentPage === 1;
            prev.addEventListener('click', () => {
                if (state.currentPage > 1) { state.currentPage--; renderTable(); }
            });
            pagerDiv.appendChild(prev);

            const span = document.createElement('span');
            span.textContent = 'Page ' + state.currentPage + ' of ' + pages;
            pagerDiv.appendChild(span);

            const next = document.createElement('button');
            next.className = 'fs-secondary';
            next.textContent = 'Next';
            next.disabled = state.currentPage === pages;
            next.addEventListener('click', () => {
                if (state.currentPage < pages) { state.currentPage++; renderTable(); }
            });
            pagerDiv.appendChild(next);
        }

        async function downloadOne(fileId) {
            try {
                const res = await fetch(apiBaseUrl + '/api/files/' + fileId, { headers: headers() });
                if (!res.ok) throw new Error('Get file failed: ' + res.status);
                const data = await res.json();
                const downloadUrl = data.DownloadUrl || data.downloadUrl;
                if (downloadUrl) {
                    window.open(downloadUrl, '_blank');
                }
            } catch (err) {
                alert('Download failed: ' + err.message);
            }
        }

        async function downloadSelected() {
            const ids = Array.from(state.selectedIds);
            if (ids.length === 0) { alert('No files selected.'); return; }
            el('listStatus').textContent = 'Requesting zip for ' + ids.length + ' files...';
            
            try {
                const res = await fetch(apiBaseUrl + '/api/files/download-zip', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...Object.fromEntries(headers())
                    },
                    body: JSON.stringify(ids)
                });

                // New behavior: 202 + job polling; fallback to direct download if not 202
                if (res.status !== 202) {
                    if (!res.ok) throw new Error('Zip request failed: ' + res.status);
                    const blob = await res.blob();
                    if (blob.size === 0) throw new Error('Received empty zip');
                    const url = URL.createObjectURL(blob);
                    window.open(url, '_blank');
                    el('listStatus').innerHTML = '<span class="fs-success">Zip ready.</span>';
                    return;
                }

                const job = await res.json();
                const jobId = job.JobId || job.jobId;
                if (!jobId) throw new Error('No job ID returned');
                el('listStatus').textContent = 'Zip job started (' + jobId + '). Processing...';

                await pollZipJob(jobId);
            } catch (err) {
                el('listStatus').innerHTML = '<span class="fs-error">' + err.message + '</span>';
            }
        }

        async function pollZipJob(jobId) {
            let attempts = 0;
            const maxAttempts = 60;
            const interval = setInterval(async () => {
                attempts++;
                try {
                    const res = await fetch(apiBaseUrl + '/api/files/download-zip/' + jobId, { headers: headers() });
                    if (!res.ok) throw new Error('Poll failed: ' + res.status);
                    const status = await res.json();

                    const st = status.status || status.Status;
                    const url = status.downloadUrl || status.DownloadUrl;

                    if (st === 'Completed') {
                        clearInterval(interval);
                        if (!url) {
                            el('listStatus').innerHTML = '<span class="fs-error">Zip ready but no download URL returned.</span>';
                            return;
                        }
                        el('listStatus').innerHTML = '<span class="fs-success">Zip ready! <a href="' + url + '" target="_blank">Download zip</a></span>';
                        window.location.href = url;
                        // optional cleanup after 30s
                        setTimeout(() => {
                            fetch(apiBaseUrl + '/api/files/download-zip/' + jobId, { method: 'DELETE', headers: headers() }).catch(() => {});
                        }, 30000);
                    } else if (st === 'Failed') {
                        clearInterval(interval);
                        el('listStatus').innerHTML = '<span class="fs-error">Zip job failed.</span>';
                    } else {
                        el('listStatus').textContent = 'Zipping... attempt ' + attempts + '/' + maxAttempts + ' Status: ' + st;
                    }
                } catch (err) {
                    clearInterval(interval);
                    el('listStatus').innerHTML = '<span class="fs-error">' + err.message + '</span>';
                }

                if (attempts >= maxAttempts) {
                    clearInterval(interval);
                    el('listStatus').innerHTML = '<span class="fs-error">Zip did not complete after ' + maxAttempts + ' attempts.</span>';
                }
            }, 1000);
        }

        async function previewFile(fileId) {
            try {
                const res = await fetch(apiBaseUrl + '/api/files/' + fileId, { headers: headers() });
                if (!res.ok) throw new Error('Get file failed: ' + res.status);
                const data = await res.json();
                const downloadUrl = data.DownloadUrl || data.downloadUrl;
                const fileName = data.FileName || data.fileName || 'file';
                if (!downloadUrl) throw new Error('No download URL');
                
                el('previewTitle').textContent = 'Preview: ' + fileName;
                const contentType = (data.ContentType || data.contentType || '').toLowerCase();
                
                const previewBody = el('previewBody');
                previewBody.innerHTML = '';
                
                if (contentType.includes('image') || contentType.includes('pdf')) {
                    // Use iframe for images and PDFs; show helpful message if blocked
                    const iframe = document.createElement('iframe');
                    iframe.src = downloadUrl;
                    iframe.style.width = '100%';
                    iframe.style.height = '100%';
                    iframe.style.border = 'none';
                    previewBody.appendChild(iframe);

                    const blockedMsg = () => {
                        const msg = document.createElement('div');
                        msg.className = 'fs-error';
                        msg.style.padding = '12px';
                        msg.innerHTML = 'This content is blocked. Contact the site owner to fix the issue.<br>Preview may be restricted by site policy (X-Frame-Options or Content-Security-Policy). Use Open in New Tab or Download.';
                        previewBody.innerHTML = '';
                        previewBody.appendChild(msg);
                    };

                    // If iframe errors, show the blocked message
                    iframe.addEventListener('error', blockedMsg);
                    // Fallback: if no load within 2s for PDFs, assume blocked
                    if (contentType.includes('pdf')) {
                        let loaded = false;
                        iframe.addEventListener('load', () => { loaded = true; });
                        setTimeout(() => { if (!loaded) blockedMsg(); }, 2000);
                    }
                } else if (contentType.includes('text') || contentType.includes('json') || contentType.includes('xml')) {
                    // For text, try to fetch and display
                    try {
                        const textRes = await fetch(downloadUrl, { mode: 'no-cors' });
                        const text = await textRes.text();
                        const pre = document.createElement('pre');
                        pre.className = 'fs-preview-pre';
                        pre.textContent = text.length > 50000 ? text.substring(0, 50000) + '\n... (truncated)' : text;
                        previewBody.appendChild(pre);
                    } catch (err) {
                        // If fetch fails, just show link
                        const msg = document.createElement('div');
                        msg.className = 'fs-muted';
                        msg.innerHTML = 'Text preview unavailable due to browser restrictions.<br><a href="' + downloadUrl + '" target="_blank">Open in New Tab</a>';
                        previewBody.appendChild(msg);
                    }
                } else {
                    // For other types, show message and link
                    const msg = document.createElement('div');
                    msg.className = 'fs-muted';
                    msg.innerHTML = 'Preview not available for file type: ' + contentType + '<br><a href="' + downloadUrl + '" target="_blank">Open in New Tab</a>';
                    previewBody.appendChild(msg);
                }
                
                el('previewOverlay').style.display = 'flex';
                el('btnOpenInTab').onclick = () => window.open(downloadUrl, '_blank');
            } catch (err) {
                console.error('[FileServiceTools] Preview error:', err);
                el('previewBody').innerHTML = '<div class="fs-error">Preview failed: ' + err.message + '</div>';
                el('previewOverlay').style.display = 'flex';
            }
        }

        async function deleteSelected() {
            if (state.selectedIds.size === 0) { alert('No files selected.'); return; }
            if (!confirm('Delete ' + state.selectedIds.size + ' file(s)?')) return;
            let deleted = 0;
            for (const id of state.selectedIds) {
                try {
                    const res = await fetch(apiBaseUrl + '/api/files/' + id, { method: 'DELETE', headers: headers() });
                    if (res.ok) deleted++;
                } catch (err) {}
            }
            alert('Deleted ' + deleted + ' file(s).');
            await refreshList();
        }

        function setupEventListeners() {
            console.log('[FileServiceTools] Setting up event listeners...');
            
            // Upload buttons
            el('btnUploadSingle').addEventListener('click', uploadSingle);
            el('btnUploadMulti').addEventListener('click', uploadMultiple);
            el('btnRefresh').addEventListener('click', refreshList);
            el('btnDeleteSelected').addEventListener('click', deleteSelected);
            el('btnDownloadSelected').addEventListener('click', downloadSelected);
            el('btnCancelUploads').addEventListener('click', () => {
                if (state.abortController) state.abortController.abort();
                resetProgress();
            });

            el('btnClosePreview').addEventListener('click', () => {
                el('previewOverlay').style.display = 'none';
            });
            
            console.log('[FileServiceTools] Event listeners attached');
        }

        // Initialize on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('[FileServiceTools] DOM loaded, initializing...');
                setupEventListeners();
                refreshList();
            });
        } else {
            // DOM already loaded
            console.log('[FileServiceTools] DOM already loaded, initializing immediately...');
            setupEventListeners();
            refreshList();
        }
    </script>
</body>
</html>
