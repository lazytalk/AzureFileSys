<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Staging Tools - File Service</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; color: #222; }
    h1 { margin: 0 0 12px; }
    fieldset { border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-bottom: 16px; }
    legend { font-weight: 600; }
    label { display: inline-block; margin-right: 12px; }
    input[type="text"] { width: 360px; padding: 6px 8px; border: 1px solid #ccc; border-radius: 6px; }
    input[type="file"] { padding: 6px 0; }
    button { padding: 8px 12px; border: 1px solid #0078d4; background: #0078d4; color: #fff; border-radius: 6px; cursor: pointer; }
    button.secondary { border-color: #555; background: #fff; color: #222; }
    button + button { margin-left: 8px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .muted { color: #666; }
    .progress { height: 10px; background: #eee; border-radius: 6px; overflow: hidden; margin-top: 8px; }
    .bar { height: 100%; background: #28a745; width: 0%; transition: width 0.1s linear; }
    .stats { margin-top: 6px; font-size: 13px; }
    .table-wrap { width: 100%; overflow-x: auto; }
    table { width: 100%; border-collapse: collapse; margin-top: 12px; min-width: 800px; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; }
    th { background: #f7f7f7; }
    .right { text-align: right; }
    .danger { background: #c62828; border-color: #c62828; }
    .success { color: #1b5e20; }
    .error { color: #b00020; }
    .hidden { display: none; }
    .small { font-size: 12px; }
    .small-btn { padding: 6px 10px; font-size: 12px; }
    .actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .pager { display: flex; align-items: center; gap: 12px; justify-content: flex-end; margin-top: 10px; }
    @media (max-width: 600px) {
      body { margin: 12px; }
      input[type="text"] { width: 100%; }
      table { min-width: 600px; }
      .actions { flex-direction: row; }
      .actions button { flex: 1 0 auto; }
      .row { gap: 8px; }
    }
  </style>
</head>"HmacSharedSecret" = ""  # Leave empty to auto-generate; or provide a Base64 secret"HmacSharedSecret" = ""  # Leave empty to auto-generate; or provide a Base64 secret"HmacSharedSecret" = ""  # Leave empty to auto-generate; or provide a Base64 secret
<body>
  <h1>Staging Tools</h1>
  <p class="muted small">Calls the staging environment APIs directly. Provide PowerSchool user & role headers to authenticate.</p>

  <fieldset>
    <legend>Environment & Auth</legend>
    <div class="row">
      <label>
        Base URL
        <input id="baseUrl" type="text" value="https://filesvc-stg-app.kaiweneducation.com" />
      </label>
      <label>
        X-PowerSchool-User
        <input id="psUser" type="text" value="admin1"/>
      </label>
      <label>
        X-PowerSchool-Role
        <input id="psRole" type="text" value="admin" />
      </label>
      <label>
        HMAC Shared Secret
        <input id="hmacSecretInput" type="password" value="abcdefg" placeholder="Enter secret from Key Vault" />
      </label>
      <label>
        <input id="includeAll" type="checkbox" checked /> Include all users (admin only)
      </label>
    </div>
    <div class="small muted">Ensure your app’s CORS allows this page’s origin. If loading from file://, some browsers restrict requests; prefer serving via a local HTTP server.</div>
  </fieldset>

  <fieldset>
    <legend>Upload Files</legend>
    <div class="row">
      <input id="singleFile" type="file" />
      <button id="btnUploadSingle">Upload One</button>
    </div>
    <div class="row" style="margin-top:8px;">
      <input id="multiFiles" type="file" multiple />
      <button id="btnUploadMulti">Upload Multiple</button>
      <button id="btnCancelUploads" class="secondary">Cancel</button>
    </div>
    <div class="progress"><div id="progressBar" class="bar"></div></div>
    <div id="progressStats" class="stats muted">Idle</div>
    <div id="uploadStatus" class="small"></div>
  </fieldset>

  <fieldset>
    <legend>Files</legend>
    <div class="row">
      <button id="btnRefresh">Refresh List</button>
      <button id="btnDeleteSelected" class="danger">Delete Selected</button>
      <button id="btnDownloadSelected" class="secondary" style="border-color: #0078d4; color: #0078d4;">Download Selected (Zip)</button>
    </div>
    <div class="table-wrap">
    <table id="filesTable">
      <thead>
        <tr>
          <th><input type="checkbox" id="checkAll" /></th>
          <th>File Name</th>
          <th>Content Type</th>
          <th class="right">Size</th>
          <th>Owner</th>
          <th>Uploaded At</th>
          <th>Actions</th>
          <th>Id</th>
        </tr>
      </thead>
      <tbody id="filesBody"></tbody>
    </table>
    </div>
    <div id="listStatus" class="small"></div>
    <div id="pager"></div>
  </fieldset>

  <!-- Preview Modal -->
  <div id="previewOverlay" class="hidden" style="position:fixed; inset:0; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:9999;">
    <div style="background:#fff; width:90%; max-width:1000px; height:80vh; border-radius:8px; box-shadow:0 6px 24px rgba(0,0,0,0.2); display:flex; flex-direction:column;">
      <div style="padding:10px 12px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:center;">
        <strong id="previewTitle">Preview</strong>
        <div>
          <button id="btnOpenInTab" class="secondary">Open in New Tab</button>
          <button id="btnClosePreview" class="secondary">Close</button>
        </div>
      </div>
      <div id="previewBody" style="flex:1; background:#fafafa; display:flex; align-items:center; justify-content:center; overflow:auto;">
        <div class="muted">Loading preview...</div>
      </div>
      <div id="previewFooter" class="small muted" style="padding:8px 12px; border-top:1px solid #eee;">If the preview fails, try Open in New Tab or Download.</div>
    </div>
  </div>

  <script>
    const el = id => document.getElementById(id);

    // HMAC-SHA256 signature generation (requires Web Crypto API)
    async function computeHmacSignature(message, secret) {
      const encoder = new TextEncoder();
      const keyData = encoder.encode(secret);
      const messageData = encoder.encode(message);
      
      const key = await crypto.subtle.importKey(
        'raw',
        keyData,
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
      );
      
      const signature = await crypto.subtle.sign('HMAC', key, messageData);
      return btoa(String.fromCharCode(...new Uint8Array(signature)));
    }

    const state = {
      abortController: null,
      totalBytes: 0,
      uploadedBytes: 0,
      startTime: 0,
      lastUpdateTime: 0,
      lastUploadedBytes: 0,
      listItems: [],
      selectedIds: new Set(),
      pageSize: 10,
      currentPage: 1,
    };

    function getHmacSecret() {
      return el('hmacSecretInput').value.trim();
    }

    async function headers(method = 'GET', path = '') {
      const h = new Headers();
      const user = el('psUser').value.trim();
      const role = el('psRole').value.trim();
      if (user) h.set('X-PowerSchool-User', user);
      if (role) h.set('X-PowerSchool-Role', role);
      
      // Add HMAC signature if secret is configured
      const secret = getHmacSecret();
      if (secret) {
        const timestamp = Math.floor(Date.now() / 1000);
        const message = `${timestamp}${method}${path}${user}${role}`;
        const signature = await computeHmacSignature(message, secret);
        console.log(`[HMAC] Method: ${method}, Path: ${path}, User: ${user}, Role: ${role}`);
        console.log(`[HMAC] Message: ${message}`);
        console.log(`[HMAC] Signature: ${signature}`);
        h.set('X-Timestamp', timestamp.toString());
        h.set('X-Signature', signature);
      } else {
        console.warn('[HMAC] No secret configured - request will not be signed');
      }
      
      return h;
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024, sizes = ['B','KB','MB','GB','TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return `${(bytes / Math.pow(k, i)).toFixed(2)} ${sizes[i]}`;
    }

    function setProgress(percent, speedBps) {
      const pct = Math.max(0, Math.min(100, percent));
      el('progressBar').style.width = pct + '%';
      const speed = speedBps ? `${formatBytes(speedBps)}/s` : '—';
      const stats = `Progress: ${pct.toFixed(1)}% • Speed: ${speed} • ${formatBytes(state.uploadedBytes)} / ${formatBytes(state.totalBytes)}`;
      el('progressStats').textContent = stats;
    }

    function resetProgress() {
      state.totalBytes = 0;
      state.uploadedBytes = 0;
      state.startTime = 0;
      state.lastUpdateTime = 0;
      state.lastUploadedBytes = 0;
      setProgress(0, 0);
      el('uploadStatus').textContent = '';
    }

    function xhrUpload(file, baseUrl) {
      return new Promise(async (resolve, reject) => {
        try {
          // Step 1: Begin Upload (Get SAS)
          const beginPayload = {
            fileName: file.name,
            sizeBytes: file.size,
            contentType: file.type || 'application/octet-stream'
          };
          
          el('uploadStatus').innerHTML = 'Requesting upload slot...';
          const h1 = await headers('POST', '/api/files/begin-upload');
          const beginRes = await fetch(`${baseUrl}/api/files/begin-upload`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              ...Object.fromEntries(h1)
            },
            body: JSON.stringify(beginPayload)
          });

          if (!beginRes.ok) {
              const errText = await beginRes.text();
              throw new Error(`Begin-upload failed: ${beginRes.status} - ${errText}`);
          }
          const beginJson = await beginRes.json();
          const fileId = beginJson.fileId || beginJson.FileId;
          const uploadUrl = beginJson.uploadUrl || beginJson.UploadUrl;

          if (!fileId || !uploadUrl) throw new Error('Invalid server response (missing fileId or uploadUrl)');

          // Step 2: Upload to Blob (Direct PUT)
          el('uploadStatus').innerHTML = 'Uploading to blob storage...';
          
          const xhr = new XMLHttpRequest();
          xhr.open('PUT', uploadUrl);
          xhr.setRequestHeader('x-ms-blob-type', 'BlockBlob'); // Vital for Azure Block Blobs
          xhr.setRequestHeader('x-ms-blob-content-type', file.type || 'application/octet-stream'); // Ensure correct Content-Type on the blob
          // No auth headers here - SAS token is in the URL

          xhr.upload.onprogress = (e) => {
            if (e.lengthComputable) {
              const now = performance.now();
              // Calculate delta since last progress event isn't easy with multiple files,
              // so we just track total for "this" file relative to global state?
              // Simplified: We assume single stream tracking for the bar here.
              // For multi-file, this logic is a bit simple but suffices for a tool.
              const currentFileUploaded = e.loaded; // Bytes uploaded for THIS file
              // We need to feed this back to the global state. 
              // BUT: The global state design above (state.uploadedBytes) accumulates.
              // Let's just update the UI with "current file" logic or fix the tracker.
              // Fix: We'll just update based on delta from THIS XHR instance.
              
              const delta = e.loaded - (xhr.lastLoaded || 0);
              xhr.lastLoaded = e.loaded;
              
              state.uploadedBytes += delta;
              const elapsedMs = now - state.startTime;
              const speed = elapsedMs > 0 ? (state.uploadedBytes / (elapsedMs / 1000)) : 0;
              const percent = state.totalBytes > 0 ? (state.uploadedBytes / state.totalBytes) * 100 : 0;
              setProgress(percent, speed);
            }
          };

          xhr.onreadystatechange = async () => {
            if (xhr.readyState === 4) {
              if (xhr.status >= 200 && xhr.status < 300) {
                 // Step 3: Complete Upload
                 try {
                     el('uploadStatus').innerHTML = 'Finalizing upload...';
                     const h2 = await headers('POST', `/api/files/complete-upload/${fileId}`);
                     const completeRes = await fetch(`${baseUrl}/api/files/complete-upload/${fileId}`, {
                         method: 'POST',
                         headers: Object.fromEntries(h2)
                     });
                     if (!completeRes.ok) {
                         const errText = await completeRes.text();
                         throw new Error(`Complete-upload failed: ${completeRes.status} - ${errText}`);
                     }
                     resolve('OK');
                 } catch (err) {
                     reject(err);
                 }
              } else {
                reject(new Error(`Blob upload failed: ${xhr.status} ${xhr.statusText}`));
              }
            }
          };

          xhr.onerror = () => reject(new Error('Network error during blob upload'));
          xhr.onabort = () => reject(new Error('Upload aborted'));
          xhr.send(file);
          
        } catch (err) {
          reject(err);
        }
      });
    }

    async function uploadSingle() {
      resetProgress();
      const baseUrl = el('baseUrl').value.trim();
      const userHdr = el('psUser').value.trim();
      if (!userHdr) { el('uploadStatus').innerHTML = '<span class="error">Please enter X-PowerSchool-User.</span>'; return; }
      const file = el('singleFile').files[0];
      if (!file) { el('uploadStatus').textContent = 'Please choose a file.'; return; }

      state.totalBytes = file.size;
      state.startTime = performance.now();
      state.lastUploadedBytes = 0;
      try {
        await xhrUpload(file, baseUrl);
        setProgress(100, 0);
        el('uploadStatus').innerHTML = '<span class="success">Upload complete.</span>';
        await refreshList();
      } catch (err) {
        el('uploadStatus').innerHTML = `<span class="error">${err.message}</span>`;
      }
    }

    async function uploadMultiple() {
      resetProgress();
      const baseUrl = el('baseUrl').value.trim();
      const userHdr = el('psUser').value.trim();
      if (!userHdr) { el('uploadStatus').innerHTML = '<span class="error">Please enter X-PowerSchool-User.</span>'; return; }
      const files = Array.from(el('multiFiles').files || []);
      if (files.length === 0) { el('uploadStatus').textContent = 'Please choose files.'; return; }

      state.totalBytes = files.reduce((sum, f) => sum + f.size, 0);
      state.startTime = performance.now();
      try {
        for (const file of files) {
          state.lastUploadedBytes = 0; // per-file progress baseline
          await xhrUpload(file, baseUrl);
        }
        setProgress(100, 0);
        el('uploadStatus').innerHTML = `<span class="success">Uploaded ${files.length} files.</span>`;
        await refreshList();
      } catch (err) {
        el('uploadStatus').innerHTML = `<span class="error">${err.message}</span>`;
      }
    }

    async function refreshList() {
      const baseUrl = el('baseUrl').value.trim();
      const includeAll = el('includeAll').checked;
      const path = `/api/files`;
      const url = `${baseUrl}${path}${includeAll ? '?all=true' : ''}`;
      el('listStatus').textContent = 'Loading...';
      try {
        const h = await headers('GET', path);
        const res = await fetch(url, { headers: h, mode: 'cors' });
        if (!res.ok) throw new Error(`List failed: ${res.status}`);
        const data = await res.json();
        setList(Array.isArray(data) ? data : []);
      } catch (err) {
        el('listStatus').innerHTML = `<span class="error">${err.message}</span>`;
      }
    }

    function setList(items) {
      state.listItems = items || [];
      state.selectedIds = new Set();
      state.currentPage = 1;
      renderTable();
    }

    function renderTable() {
      const total = state.listItems.length;
      const pages = Math.max(1, Math.ceil(total / state.pageSize));
      if (state.currentPage > pages) state.currentPage = pages;
      const start = (state.currentPage - 1) * state.pageSize;
      const pageItems = state.listItems.slice(start, start + state.pageSize);

      const tbody = el('filesBody');
      tbody.innerHTML = '';
      for (const item of pageItems) {
        const tr = document.createElement('tr');
        const size = item.SizeBytes ?? item.sizeBytes ?? item.Size ?? 0;
        const uploadedAt = item.UploadedAt ?? item.uploadedAt ?? item.CreatedAt ?? '';
        const owner = item.OwnerUserId ?? item.ownerUserId ?? item.CreatedBy ?? '';
        const id = item.Id ?? item.id ?? '';
        const name = item.FileName ?? item.fileName ?? '';
        const ct = item.ContentType ?? item.contentType ?? '';

        const checkedAttr = state.selectedIds.has(String(id)) ? 'checked' : '';
        tr.innerHTML = `
          <td><input type="checkbox" class="rowCheck" data-id="${id}" ${checkedAttr} /></td>
          <td>${name}</td>
          <td>${ct}</td>
          <td class="right">${formatBytes(Number(size) || 0)}</td>
          <td>${owner}</td>
          <td>${uploadedAt ? new Date(uploadedAt).toLocaleString() : ''}</td>
          <td>
            <div class="actions">
              <button class="small-btn preview-btn" data-id="${id}" data-name="${name}" data-ct="${ct}">Preview</button>
              <button class="small-btn download-btn" data-id="${id}">Download</button>
            </div>
          </td>
          <td class="small">${id}</td>
        `;
        tbody.appendChild(tr);
      }

      // Wire up row buttons
      document.querySelectorAll('.download-btn').forEach(btn => {
          btn.addEventListener('click', (e) => downloadOne(e.target.getAttribute('data-id')));
      });
      document.querySelectorAll('.preview-btn').forEach(btn => {
          btn.addEventListener('click', (e) => previewOne(
            e.target.getAttribute('data-id'),
            e.target.getAttribute('data-name'),
            e.target.getAttribute('data-ct')
          ));
      });

      // Wire up checkbox changes to persist selection
      document.querySelectorAll('.rowCheck').forEach(cb => {
        cb.addEventListener('change', (e) => {
          const id = e.target.getAttribute('data-id');
          if (e.target.checked) state.selectedIds.add(String(id));
          else state.selectedIds.delete(String(id));
        });
      });

      renderPager();
      el('listStatus').textContent = `Loaded ${total} items. Page ${state.currentPage} of ${pages}.`;
    }

    function renderPager() {
      const total = state.listItems.length;
      const pages = Math.max(1, Math.ceil(total / state.pageSize));
      const pager = el('pager');
      const disPrev = state.currentPage <= 1 ? 'disabled' : '';
      const disNext = state.currentPage >= pages ? 'disabled' : '';
      pager.innerHTML = `
        <div class="pager">
          <button id="pagePrev" class="secondary" ${disPrev}>Prev</button>
          <span class="small">Page ${state.currentPage} of ${pages}</span>
          <button id="pageNext" class="secondary" ${disNext}>Next</button>
        </div>
      `;
      const prev = document.getElementById('pagePrev');
      const next = document.getElementById('pageNext');
      if (prev) prev.addEventListener('click', () => { if (state.currentPage > 1) { state.currentPage--; renderTable(); } });
      if (next) next.addEventListener('click', () => { const p = Math.max(1, Math.ceil(total / state.pageSize)); if (state.currentPage < p) { state.currentPage++; renderTable(); } });
    }

    async function downloadOne(id) {
        const baseUrl = el('baseUrl').value.trim();
      try {
        const data = await getReadSas(baseUrl, id);
        const url = data.downloadUrl || data.DownloadUrl;
        if (url) {
          window.open(url, '_blank');
        } else {
          alert('No download URL returned');
        }
      } catch (err) {
        alert('Download error: ' + err.message);
      }
    }

    async function getReadSas(baseUrl, id) {
      const h = await headers('GET', `/api/files/${id}`);
      const res = await fetch(`${baseUrl}/api/files/${id}`, { headers: h, mode: 'cors' });
      if (!res.ok) {
        const text = await res.text().catch(() => '');
        throw new Error(`Get failed: ${res.status} ${text}`);
      }
      return await res.json();
    }

    async function previewOne(id, nameFromRow, ctFromRow) {
      const baseUrl = el('baseUrl').value.trim();
      try {
        const sas = await getReadSas(baseUrl, id);
        const url = sas.downloadUrl || sas.DownloadUrl || sas.url || sas.Url;
        const name = nameFromRow || sas.fileName || sas.FileName || 'File';
        const ct = ctFromRow || sas.contentType || sas.ContentType || guessContentType(name);

        const overlay = el('previewOverlay');
        const body = el('previewBody');
        const title = el('previewTitle');
        title.textContent = name;
        body.innerHTML = '<div class="muted">Loading preview...</div>';

        function openInTab() {
          try { window.open(url, '_blank', 'noopener'); } catch {}
        }
        const btnOpen = el('btnOpenInTab');
        btnOpen.onclick = openInTab;

        let contentEl;
        if (ct.startsWith('image/')) {
          const img = document.createElement('img');
          img.src = url;
          img.alt = name;
          img.style.maxWidth = '100%';
          img.style.maxHeight = '100%';
          contentEl = img;
        } else if (ct === 'application/pdf' || name.toLowerCase().endsWith('.pdf')) {
          const iframe = document.createElement('iframe');
          iframe.src = url;
          iframe.style.width = '100%';
          iframe.style.height = '100%';
          iframe.setAttribute('title', name);
          contentEl = iframe;
        } else if (isOfficeDocument(name)) {
          const ovUrl = `https://view.officeapps.live.com/op/view.aspx?src=${encodeURIComponent(url)}`;
          const iframe = document.createElement('iframe');
          iframe.src = ovUrl;
          iframe.style.width = '100%';
          iframe.style.height = '100%';
          iframe.setAttribute('title', name);
          contentEl = iframe;
        } else {
          const iframe = document.createElement('iframe');
          iframe.src = url;
          iframe.style.width = '100%';
          iframe.style.height = '100%';
          iframe.setAttribute('title', name);
          contentEl = iframe;
        }

            body.innerHTML = '';
            body.appendChild(contentEl);
            overlay.classList.remove('hidden');
            overlay.style.display = 'flex';

      } catch (err) {
        console.error('Preview error', err);
        alert('Preview failed. Try Open in New Tab or Download.');
      }
    }

    function guessContentType(name) {
      const n = (name || '').toLowerCase();
      if (n.endsWith('.png')) return 'image/png';
      if (n.endsWith('.jpg') || n.endsWith('.jpeg')) return 'image/jpeg';
      if (n.endsWith('.gif')) return 'image/gif';
      if (n.endsWith('.webp')) return 'image/webp';
      if (n.endsWith('.svg')) return 'image/svg+xml';
      if (n.endsWith('.pdf')) return 'application/pdf';
      if (n.endsWith('.txt')) return 'text/plain';
      if (n.endsWith('.json')) return 'application/json';
      return 'application/octet-stream';
    }

    function isOfficeDocument(name) {
      const n = (name || '').toLowerCase();
      return n.endsWith('.doc') || n.endsWith('.docx') || n.endsWith('.ppt') || n.endsWith('.pptx') || n.endsWith('.xls') || n.endsWith('.xlsx');
    }

    function closePreview() {
      const overlay = el('previewOverlay');
      const body = el('previewBody');
      overlay.classList.add('hidden');
      overlay.style.display = 'none';
      body.innerHTML = '<div class="muted">Loading preview...</div>';
      const btnOpen = el('btnOpenInTab');
      btnOpen.onclick = null;
    }

    async function downloadSelectedZip() {
      const baseUrl = el('baseUrl').value.trim();
      const ids = Array.from(state.selectedIds);
      if (ids.length === 0) { el('listStatus').textContent = 'No files selected.'; return; }
      el('listStatus').textContent = `Zipping ${ids.length} files...`;
      
      try {
          // 1. Start Job
          el('listStatus').textContent = `Requesting zip for ${ids.length} files...`;
          const h3 = await headers('POST', '/api/files/download-zip');
          const res = await fetch(`${baseUrl}/api/files/download-zip`, {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
                  ...Object.fromEntries(h3)
              },
              body: JSON.stringify(ids)
          });
          
          if (res.status !== 202) {
              // Fallback for old behaviour if any (or error)
               if (!res.ok) throw new Error(`Zip request failed: ${res.status}`);
               // Direct download buffer response?
               const blob = await res.blob();
               if (blob.size === 0) throw new Error("Received 0 bytes");
               downloadBlob(blob);
               return;
          }

          const jobJson = await res.json();
          const jobId = jobJson.jobId || jobJson.JobId;
          el('listStatus').textContent = `Zip job started (${jobId}). Processing...`;

          // 2. Poll Status
          await pollZipJob(baseUrl, jobId);
          
      } catch (err) {
          el('listStatus').innerHTML = `<span class="error">${err.message}</span>`;
      }
    }

    async function pollZipJob(baseUrl, jobId) {
        let attempts = 0;
        const maxAttempts = 60; // 2 minutes approx
        
        const interval = setInterval(async () => {
            attempts++;
            try {
                const h4 = await headers('GET', `/api/files/download-zip/${jobId}`);
                const res = await fetch(`${baseUrl}/api/files/download-zip/${jobId}`, { headers: h4 });
                if (!res.ok) throw new Error("Poll failed");
                const job = await res.json();
                
                if (job.status === 'Completed' || job.Status === 'Completed') {
                    clearInterval(interval);
                    const url = job.downloadUrl || job.DownloadUrl;
                    if (!url) {
                        el('listStatus').innerHTML = `<span class="error">Zip ready but no download URL returned.</span>`;
                        return;
                    }

                    // Provide a clickable link and navigate directly (avoids popup blockers)
                    const linkHtml = `<a href="${url}" target="_blank">Download zip</a>`;
                    el('listStatus').innerHTML = `<span class="success">Zip ready! ${linkHtml}</span>`;
                    window.location.href = url;
                    // Delay cleanup to allow download to start; still frees storage automatically
                    setTimeout(async () => {
                        try {
                            const h5 = await headers('DELETE', `/api/files/download-zip/${jobId}`);
                            await fetch(`${baseUrl}/api/files/download-zip/${jobId}`, { 
                                method: 'DELETE', 
                                headers: h5
                            });
                            console.log('Zip file cleaned up from storage');
                        } catch (err) {
                            console.error('Cleanup failed:', err);
                        }
                    }, 30000);
                } else if (job.status === 'Failed' || job.Status === 'Failed') {
                    clearInterval(interval);
                    el('listStatus').innerHTML = `<span class="error">Zip generation failed: ${job.error || job.Error}</span>`;
                } else {
                    el('listStatus').textContent = `Processing zip... (${attempts}s)`;
                }

                if (attempts >= maxAttempts) {
                    clearInterval(interval);
                    el('listStatus').textContent = "Zip generation timed out (check back later?)";
                }
            } catch (err) {
                console.error(err);
                // Keep trying or stop?
            }
        }, 2000);
    }

    function downloadBlob(blob) {
         const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.style.display = 'none';
          a.href = url;
          a.download = `files_export_${new Date().getTime()}.zip`;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          el('listStatus').textContent = 'Zip download started.';
    }

    async function deleteSelected() {
      const baseUrl = el('baseUrl').value.trim();
      const ids = Array.from(state.selectedIds);
      if (ids.length === 0) { el('listStatus').textContent = 'No files selected.'; return; }
      el('listStatus').textContent = `Deleting ${ids.length} files...`;
      let ok = 0, fail = 0;
      for (const id of ids) {
        try {
          const h = await headers('DELETE', `/api/files/${id}`);
          const res = await fetch(`${baseUrl}/api/files/${id}`, { method: 'DELETE', headers: h, mode: 'cors' });
          if (res.ok) ok++; else fail++;
        } catch { fail++; }
      }
      el('listStatus').textContent = `Deleted ${ok}, failed ${fail}.`;
      await refreshList();
    }

    // Check all toggle
    el('checkAll').addEventListener('change', (e) => {
      const checked = e.target.checked;
      document.querySelectorAll('.rowCheck').forEach(cb => {
        cb.checked = checked;
        const id = cb.getAttribute('data-id');
        if (checked) state.selectedIds.add(String(id));
        else state.selectedIds.delete(String(id));
      });
    });

    // Wire buttons
    el('btnUploadSingle').addEventListener('click', uploadSingle);
    el('btnUploadMulti').addEventListener('click', uploadMultiple);
    el('btnRefresh').addEventListener('click', refreshList);
    el('btnDeleteSelected').addEventListener('click', deleteSelected);
    el('btnDownloadSelected').addEventListener('click', downloadSelectedZip);
    el('btnClosePreview').addEventListener('click', closePreview);
    el('previewOverlay').addEventListener('click', (e) => { if (e.target === el('previewOverlay')) closePreview(); });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const overlay = el('previewOverlay');
        if (!overlay.classList.contains('hidden')) closePreview();
      }
    });

    // Initial list
    // Optionally auto-load list on page ready
    // refreshList();
  </script>
</body>
</html>
